// --------------------------------------------------------------------------------
// BUSCA BINÁRIA
// --------------------------------------------------------------------------------

v[] = [1, 4, 8, 8, 9, 11, 11, 12];  // Array de exemplo

// Posição do número x no array, ou -1 (caso x não estiver no array)
// Obs: Se x aparecer mais de uma vez no array, a posição irá variar de acordo com o tamanho do mesmo
funcao busca_binaria(x) {
    l = 0;  // Primeira posição do array
    r = v.tamanho - 1;  // Última posição do array

    while (l <= r) {  // Iteração no intervalo
        m = ceil((l + r) / 2);

        if (v[m] == x) {  // Se o valor for igual a x
            return m;  // Retornar m
        }
        if (v[m] < x) {  // Se o valor for menor que x
            l = m + 1;  // Reduzir o intervalo para [m+1, r]
        }
        else {  // Caso contrário
            r = m - 1;  // Reduzir o intervalo para [l, m-1]
        }
    }

    return -1;  // x não está no array
}

// Posição do primeiro número >= x no array, ou -1 (caso nenhum número no array satisfazer essa condição)
funcao lower_bound(x) {
    l = 0;  // Primeira posição do array
    r = v.tamanho - 1;  // Última posição do array
    pos = -1;  // Posição do lower bound

    while (l <= r) {  // Iteração no intervalo
        int m = ceil((l + r) / 2);

        if (v[m] >= x) {  // Se o valor for maior ou igual a x
            pos = m;  // Atualizar a posição do lower bound
            r = m - 1;  // Reduzir o intervalo para [l, m-1]
        }
        else {  // Caso contrário
            l = m + 1;  // Reduzir o intervalo para [m+1, r]
        }
    }

    return pos;  // Retornar a posição do lower bound (-1 indica que não existe um lower bound de x na lista)
}

// Posição do primeiro número > x no array, ou -1 (caso nenhum número no array satisfazer essa condição)
funcao upper_bound(x) {
    l = 0;  // Primeira posição do array
    r = v.tamanho - 1;  // Última posição do array
    pos = -1;  // Posição do upper bound

    while (l <= r) {  // Iteração no intervalo
        m = ceil((l + r) / 2);

        if (v[m] > x) {  // Se o valor for maior que x
            pos = m;  // Atualizar a posição do upper bound
            r = m - 1;  // Reduzir o intervalo para [l, m-1]
        }
        else {  // Caso contrário
            l = m + 1;  // Reduzir o intervalo para [m+1, r]
        }
    }

    return pos;  // Retornar a posição do upper bound (-1 indica que não existe um upper bound de x na lista)
}
